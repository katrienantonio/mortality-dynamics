# LifeMetrics Software 
# License Agreement
#
# This software license agreement (?Agreement?) is an agreement between JPMorgan Chase Bank, N.A.,
# (collectively with its affiliates, ?Morgan?) and you (either an individual or an entity on whose behalf the individual is acting) 
# (?you? or ?Licensee?) regarding your use of the LifeMetrics Software by JPMorgan and is effective on the date that you 
# either compile the Software Source Code or otherwise use the Products (?Agreement Effective Date?). 
#
# BEFORE YOU EITHER COMPILE THE SOFTWARE SOURCE CODE OR OTHERWISE USE THE PRODUCTS, CAREFULLY READ THE TERMS AND CONDITIONS 
# OF THIS AGREEMENT BELOW. BY COMPILING THE SOFTWARE SOURCE CODE OR USING THE PRODUCTS IN ANY MANNER, YOU ARE AGREEING TO BE 
# BOUND BY AND ARE BECOMING A PARTY TO THIS AGREEMENT. IF YOU DO NOT AGREE TO ALL OF THE TERMS OF THIS AGREEMENT, 
# IMMEDIATELY DELETE ALL COPIES OF THE PRODUCTS FROM YOUR COMPUTER SYSTEMS.
#
#	
# 1. Grant of License.
#
# (a) Subject to the terms and conditions of this Agreement, Morgan hereby grants to Licensee, a non-transferable, 
# non-assignable, personal, revocable, non-exclusive license: (i) to compile the source code of the LifeMetrics software 
# including all components and updates thereto, and to the proprietary data contained therein, (the ?Software Source Code?) 
# using a third party product, the results of which is the Software in object code form, (?Software Object Code?), 
# (?Software Source Code? and the ?Software Object Code? are hereinafter collectively referred to as the ?Software?), 
# and (ii) to use the Software to evaluate mortality projections, and (iii) to use any Software user manuals provided by Morgan, 
# (?Manuals?).  The ?Software? and the ?Manuals? are hereinafter referred to as ?Products?.
#
# (b) No rights to use the Products are granted hereunder other than those expressly granted in Section 1(a).  
# Except as expressly authorized in this Agreement, Licensee shall not rent, lease, sublicense, distribute, transfer, 
# copy, reproduce, display, modify or timeshare the Products or any portion thereof, or use the Products as a 
# component of or a base for products or services prepared for commercial or non commercial sale, sublicense, lease, 
# access, hosting, application service providing distribution outside the Licensee's organization, or prepare any derivative work
#  based on the Products. Licensee shall not allow any third party or unlicensed user or computer system to access or use the Products.  
# Licensee shall not reverse engineer, modify in any way, or create derivative works from the Products, or any portion thereof.  
# Licensee agrees that all improvements and modifications to the Products or any part thereof (whether developed by Morgan, 
# Licensee or any third party acting on behalf of them at any time shall be and remain the sole and exclusive property of Morgan.
#
# (c) A hyperlink to a software product provided by a third party that may be used to compile the Software Source Code 
# may be provided by Morgan (?Third Party Product?).  Morgan does not endorse or assume any responsibility or liability 
# with regards to the Third Party Product. 
#
# 2. Term; Termination.
#
# This Agreement commences on the Agreement Effective Date and expires twelve (12) months thereafter (?Term?).  
# Morgan may terminate this Agreement at any time for any reason upon thirty (30) days notice, provided, 
# however if Licensee breaches any material term of this Agreement, Morgan may terminate this Agreement immediately without any notice.
#
# 3. License fee.	
#	
# There is currently no license fee for the use of the Products hereunder.  
#
# 4. Ownership.
#
# Morgan retains all right, tile and interest to the Products (including any corrections, updates, adaptations, 
# enhancements or copies).  The Products are the confidential information of Morgan.  Licensee agrees to take all reasonable 
# steps to protect the Products from unauthorized copying or use.  
#
# 5. Representations, Warranties, Disclaimers, Indemnification.
#
# (a) Morgan and Licensee each represent and warrant as to itself that (i) it is duly organized, validly existing, 
# and in good standing under the laws of the jurisdiction of its organization or incorporation, (ii) it has the power to execute 
# the Agreement and to perform its obligations under the Agreement, and (iii) such execution and performance do not violate 
# or conflict with any law applicable to it,, any order or judgment of any court or other agency of government applicable to it 
# or any of its assets, or any contractual restriction binding on or affecting it or any of its assets.
#
# (b) EXCEPT AS SET FORTH IN THIS SECTION 6, MORGAN MAKES NO WARRANTY, REPRESENTATION, CONDITION, OR AGREEMENT 
# WITH RESPECT TO THE PRODUCT OR THE THIRD PARTY PRODUCT.  MORGAN EXPRESSLY DISCLAIMS AND EXCLUDES TO THE FULLEST EXTENT PERMITTED
# BY APPLICABLE LAW ANY AND ALL IMPLIED WARRANTIES, INCLUDING ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
# FOR THE PRODUCT AND THE THIRD PARTY PRODUCT.  MORGAN SHALL HAVE NO LIABILITY, CONTINGENT OR OTHERWISE, TO LICENSEE OR TO THIRD PARTIES, 
# FOR THE ACCURACY, COMPLETENESS OR CURRENCY OF THE PRODUCT OR THE THIRD PARTY PRODUCT OR FOR DELAYS OR OMISSIONS THEREIN, OR FOR INTERRUPTIONS 
# IN THE DELIVERY OF THE PRODUCT OR THE THIRD PARTY PRODUCT.  IN NO EVENT WILL MORGAN BE LIABLE FOR ANY DIRECT, ORDINARY, 
# SPECIAL, INDIRECT, INCIDENTAL AND/OR CONSEQUENTIAL DAMAGES WHICH MAY BE INCURRED OR EXPERIENCED BY LICENSEE AND/OR ANY 
# THIRD PARTIES INCLUDING BUT NOT LIMITED TO ON ACCOUNT OF LICENSEE ENTERING INTO AND/OR LICENSEE AND/OR ANY THIRD PARTY 
# RELYING ON THIS AGREEMENT, EVEN IF MORGAN HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 
#
# (c) Licensee shall indemnify, protect, and hold harmless Morgan, its affiliates, employees and agents, 
# from and against any and all losses, liabilities, judgments, suits, actions, proceedings, claims, damages, costs 
# (including reasonable attorney's fees) resulting from or arising out of the use by Licensee of the Products and/or the Third Party Product.
#
# 6. Injunctive Relief.
#
# Licensee acknowledges that a breach of any provision of this Agreement will cause Morgan party irreparable 
# injury and damage and therefore Licensee may be enjoined through injunctive proceedings in addition to any other rights 
# and remedies which may be available to Morgan at law or in equity without the posting of a bond.  
#
# 7. General.
#
# (a) All notices and other communications under this Agreement shall be in writing and deemed given upon receipt. 
# Notwithstanding the foregoing, Morgan may provide Licensee with notice by posting such Notice it Morgan?s Web site and 
# such notice shall be deemed valid in accordance with this Agreement.  Notice to Morgan shall be made to:  
# JPMorgan Chase Bank, N.A., Technology, Sourcing, and IP Practice Group, 25th Floor, 1 Chase Manhattan Plaza, New York, NY 10081, Fax:  212-383-0800.
#
# (b) The following sections shall survive termination of this Agreement: 4, 5, 6, and 7.
#
# (c) The Agreement constitutes the entire agreement and understanding of the parties with
# respect to its subject matter and supersedes all oral communications and prior writings with respect thereto.  
# Morgan may revise this Agreement by posting such revisions to its Web site and your continued use of the Products 
# shall constitute your acceptance of such new terms.
#
# (d) Licensee cannot assign this Agreement nor any interest or obligation in or under the Agreement without Morgan?s prior written consent.
#
# (e) Morgan will not be liable for any failure, delay or omission to perform any of its obligations 
# under the Agreement arising from any cause beyond its reasonable control, including, without limitation, acts of God, 
# acts or regulations of government or other authorities, war, fire, strikes or other industrial disputes, power failure, 
# failure of telecommunication lines, connection or equipment, or failure or defects in any hardware or software owned or supplied by third parties.
#
# (f) If any provision of the Agreement is held invalid, illegal or unenforceable, the validity, 
# legality or enforceability of the remainder of the Agreement will not in any way be affected or impaired thereby.
#
# (g) Licensee hereby agrees not to export or transmit the Products to any country to which such 
# transmission is restricted by applicable regulations or statutes.  Licensee agrees to permit Morgan access to 
# Licensee?s location where the Products is installed and/or used solely to permit Morgan to ensure compliance with the terms of this Agreement.
#
# (h) The Agreement will be governed by the laws of the State of New York without reference to choice of law principles. 
# Any action or proceeding relating to this Agreement may be brought and enforced in the courts of the State of New York 
# or the United States District Court located in the Borough of Manhattan in New York City. Each of the parties 
# irrevocably submits to the jurisdiction of such courts in connection with any such action or proceeding. 
# Any process or other legal summons in connection with any such action or proceeding may be served by mailing 
# a copy thereof by certified or registered mail, or any substantially similar form of mail, addressed to a party as provided 
# for notices hereunder. THE PARTIES WAIVE TRIAL BY JURY IN RESPECT OF ANY PROCEEDINGS RELATED TO THE AGREEMENT.


fit701=function(xv,yv,etx,dtx,wa){
# Model M1
# Lee-Carter model
# log m(t,x) = beta1(x) + beta2(x).kappa2(t) + Poisson error

# Inputs:
#   xv = vector of ages, length n
#   yv = vector of years, length m
#   etx = m x n matrix of exposures
#   dtx = m x n matrix of deaths
#   wa = m x n matrix of weights (0 or 1)
xv<-as.vector(unlist(xv))
yv<-as.vector(unlist(yv))
etx<-as.matrix(etx)
dtx<-as.matrix(dtx)
wa<-as.matrix(wa)
    mtx=dtx/etx	  # matrix of death rates

    qtx=1-exp(-mtx) # matrix of mortality rates

    if(max(xv) > 89)
    {  
         cat("Upper age too high - suggest abort programme\n") 
    }

    n=length(xv)	# number of ages
    m=length(yv)	# number of years

    cy=(yv[1]-xv[n]):(yv[m]-xv[1])  # cohort approximate years of birth

    # initialise parameter vectors
    beta1v=(1:n)*0
    beta2v=(1:n)*0
    beta3v=(1:n)*0		# dummy vector, this will stay at 0
    kappa2v=(1:m)*0
    gamma3v=(1:(n+m-1))*0	# dummy vector, this will stay at 0
    ia=array((1:m),c(m,n))	# matrix of year indexes, i, for the data
    ja=t(array((1:n),c(n,m)))	# matrix of age indexes, j, for the data
    ya=ia-ja		 	# matrix of year of birth indexes for the data
    imj=(1-n):(m-1)		# the range of values taken by i-j
    lg=n+m-1		 	# number of different values taken by i-j
    ca=ya+yv[1]-xv[1]		# matrix of years of birth

    # Now set weights to zero for cohorts with fewer than 5 observations
    for(k in 1:lg)
    {
        nk=sum((ca == cy[k])*wa)
	  if(nk < 5)
        {
	      wa=wa*(1- (ca == cy[k]))
	  }
    }

    ww=cy*0+1	 # this is a vector of 1's and 0's with
		 	 # a 0 if the cohort is completely excluded
    for(k in 1:lg)
    {
        ww[k]=ww[k]*(sum((ca == cy[k])*wa) > 0)
    }

    # Stage 0
    # Gives initial estimates for beta1(x), beta2(x) and kappa2(t)
    mx=mean(xv)
    for(j in 1:n)
    {
     beta1v[j]=sum(log(mtx[,j])*wa[,j])/sum(wa[,j])
	  beta2v[j]=1/n
    }
    kappa2v=(m:1)-(m+1)/2

    # Stage 1: iterate
    l0=-1000000
    l1=-999999
    iteration=0
    # l1 is the latest estimate of the log-likelihood
    # l0 is the previous estimate
    # we continue to iterate if the improvement in log-likelihood
    # exceeds 0.0001
    while(abs(l1-l0) > 0.0001)
    {
        iteration=iteration+1

	  l0=l1
        # Stage 1B optimise over the beta2(x)
	  for(j in 1:n)
        {		 		 
            # cycle through the range of years
		dv=dtx[,j]	# actual deaths
		ev=etx[,j]	# exposure
		beta2v[j]=llmaxM2B(beta1v[j],beta2v[j],beta3v[j],
                                kappa2v,gamma3v[(n+1-j):(n+m-j)],dv,ev,wv=wa[,j])
	  }
		 		 		 
	  mhat=mtx*0
	  for(i in 1:m)
        {
	      mhat[i,]=exp(beta1v+beta2v*kappa2v[i]+beta3v*gamma3v[(n+i-1):i])
	  }
	  epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)
	  l1=sum((dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1))*wa)
	  cat(l1,"-> ")

        # Stage 1D optimise over the kappa2(t)
	  for(i in 1:m)
        {		 		 
            # cycle through the range of years
	      dv=dtx[i,]	# actual deaths
		ev=etx[i,]	# exposure
		kappa2v[i]=llmaxM2D(beta1v,beta2v,beta3v,
                                 kappa2v[i],gamma3v[(n+i-1):i],dv,ev,wv=wa[i,])
	  }

        # Now apply the constraints
        fac21=mean(kappa2v)
	  fac22=sum(beta2v)
	  kappa2v=fac22*(kappa2v-fac21)    # ensures that the kappas sum to 0
	  beta2v=beta2v/fac22		     # ensures that the beta2's sum to 1
	  beta1v=beta1v+beta2v*fac22*fac21 # => beta1 needs to be adjusted to compensate

	  mhat=mtx*0
	  for(i in 1:m)
        {
            mhat[i,]=exp(beta1v+beta2v*kappa2v[i]+beta3v*gamma3v[(n+i-1):i])
	  }
	  epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)
	  l1=sum((dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1))*wa)
	  cat(l1," ->")

        # Stage 1A optimise over the beta1(x)
	  for(j in 1:n)
        {		 		 
            # cycle through the range of years
		wv=1	    # can be set to a vector of weights
		 	    # to e.g. exclude duff years
		wv=wa[,j]
		s1=sum(wv*dtx[,j])
		s2=sum(wv*etx[,j]*exp(beta2v[j]*kappa2v+beta3v[j]*gamma3v[(n+1-j):(n+m-j)]))
		beta1v[j]=log(s1)-log(s2)
	   }
		 		 
	   mhat=mtx*0
	   for(i in 1:m)
         {
	       mhat[i,]=exp(beta1v+beta2v*kappa2v[i]+beta3v*gamma3v[(n+i-1):i])
	   }
	   epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)
	   l1=sum((dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1))*wa)
	   cat(l1,"\n")

    }		 # end while loop

    # calculate number of parameters and deduct 4 for the number of constraints
    npar=length(beta1v)+length(beta2v)+length(kappa2v)-2

    # Calculate the BIC
    BIC=l1-0.5*log(sum(wa))*npar

    list(beta1=beta1v,beta2=beta2v,beta3=beta3v,
          kappa2=kappa2v,gamma3=gamma3v,x=xv,y=yv,cy=cy,
          wa=wa,epsilon=epsilon,mhat=mhat,ll=l1,BIC=BIC,npar=npar,mtxLastYear = mtx[m,])		 
}




fit702=function(xv,yv,etx,dtx,wa){
# Model M2
# Renshaw-Haberman 3-factor model
# log m(t,x) = beta1(x) + beta2(x).kappa2(t) +beta3(x).gamma3(t-x) + Poisson error

# Inputs:
#   xv = vector of ages, length n
#   yv = vector of years, length m
#   etx = m x n matrix of exposures
#   dtx = m x n matrix of deaths
#   wa = m x n matrix of weights (0 or 1)

    mtx=dtx/etx	   # matrix of death rates
    qtx=1-exp(-mtx)  # matrix of mortality rates

    if(max(xv) > 89)
    {
        cat("Upper age too high - suggest abort programme\n") 
    }

    n=length(xv)	# number of ages
    m=length(yv)	# number of years

    cy=(yv[1]-xv[n]):(yv[m]-xv[1])  # cohort approximate years of birth

    # next initialise parameter vectors
    beta1v=(1:n)*0
    beta2v=(1:n)*0
    beta3v=(1:n)*0		 		 
    kappa2v=(1:m)*0
    gamma3v=(1:(n+m-1))*0		 
    ia=array((1:m),c(m,n))     # matrix of year indexes, i, for the data
    ja=t(array((1:n),c(n,m)))	 # matrix of age indexes, j, for the data
    ya=ia-ja		 	 # matrix of year of birth indexes for the data
    imj=(1-n):(m-1)		 # the range of values taken by i-j
    lg=n+m-1		 	 # number of different values taken by i-j
    ca=ya+yv[1]-xv[1]          # matrix of years of birth

    # Now set weights to zero for cohorts with fewer than 5 observations
    for(k in 1:lg)
    {
        nk=sum((ca == cy[k])*wa)
	  if(nk < 5)
        {
            wa=wa*(1- (ca == cy[k]))
	  }
    }

    ww=cy*0+1  # this is a vector of 1's and 0's with
		   # a 0 if the cohort is completely excluded
    for(k in 1:lg)
    {
        ww[k]=ww[k]*(sum((ca == cy[k])*wa) > 0)
    }

    # Stage 0
    # Gives initial estimates for beta1(x), beta2(x) and kappa2(t)
    mx=mean(xv)
    for(j in 1:n)
    {
        beta1v[j]=sum(log(mtx[,j])*wa[,j])/sum(wa[,j])
	  beta2v[j]=0
	  beta3v[j]=1/n
    }
    kappa2v=(m:1)-(m+1)/2

    # Stage 1: iterations
    l0=-1000000
    l1=-999999
    iteration=0
    # l1 is the latest estimate of the log-likelihood
    # l0 is the previous estimate
    # we continue to iterate if the improvement in log-likelihood
    # exceeds 0.0001
    while(abs(l1-l0) > 0.0001)
    {
        iteration=iteration+1

        l0=l1
        # Stage 1B optimise over the beta2(x)
        for(j in 1:n)
        {		 		 
            # cycle through the range of years
		dv=dtx[,j]	# actual deaths
		ev=etx[,j]	# exposure
		beta2v[j]=llmaxM2B(beta1v[j],beta2v[j],beta3v[j],
                                kappa2v,gamma3v[(n+1-j):(n+m-j)],dv,ev,wv=wa[,j])
        }
		 
        # Next few lines calculate the fitted death rate, the standardised
        # errors and the log-likelihood
	  mhat=mtx*0
	  for(i in 1:m)
        {
            mhat[i,]=exp(beta1v+beta2v*kappa2v[i]+beta3v*gamma3v[(n+i-1):i])
        }
        epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)
        l1=sum((dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1))*wa)
	  cat(l1,"-> ")

        # Stage 1D optimise over the kappa2(t)
	  for(i in 1:m)
        {		 		 
            # cycle through the range of years
		dv=dtx[i,]		 # actual deaths
		ev=etx[i,]		 # exposure
		kappa2v[i]=llmaxM2D(beta1v,beta2v,beta3v,
                                 kappa2v[i],gamma3v[(n+i-1):i],dv,ev,wv=wa[i,])
        }

        # Next few lines calculate the fitted death rate, the standardised
        # errors and the log-likelihood
	  mhat=mtx*0
        for(i in 1:m)
        {
            mhat[i,]=exp(beta1v+beta2v*kappa2v[i]+beta3v*gamma3v[(n+i-1):i])
        }
	  epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)
        l1=sum((dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1))*wa)
        cat(l1,"->")

        # Stage 1E optimises over the gamma3(t-x)
        for(k in 1:lg)
        {
            if(ww[k] == 0)
            { 
                gamma3v[k]=0 
            }	# don't optimise of cohort excluded
            else 
            {
                id=0+(ya == imj[k])  # pick out entries with a specific year of birth
                ny=sum(id)	       # number of entries in matrix with this year of birth
                nvt=1:(n*m)
		    nvk=order(-id)[1:ny]
		    iiv=ia[nvk]
		    jjv=ja[nvk]
		    dv=dtx[nvk]
		    ev=etx[nvk]
		    wv=wa[nvk]
		    gamma3v[k]=llmaxM2E(beta1v[jjv],beta2v[jjv],beta3v[jjv],
                                     kappa2v[iiv],gamma3v[k],dv,ev,wv=wv)
		    if(gamma3v[k] > 100)
                { 
                    gamma3v[k]=100 
                }
		    if(gamma3v[k] < -100)
                {
                    gamma3v[k]=-100 
                }
            }  # end of calculations for normal cohorts
        }

        # Next few lines calculate the fitted death rate, the standardised
        # errors and the log-likelihood
        mhat=mtx*0
        for(i in 1:m)
        {
            mhat[i,]=exp(beta1v+beta2v*kappa2v[i]+beta3v*gamma3v[(n+i-1):i])
        }
        epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)
        l1=sum((dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1))*wa)
        cat(l1," -> ")

        # Stage 1C optimise over the beta3(x)
        for(j in 1:n)
        {
            # cycle through the range of years
            dv=dtx[,j]   # actual deaths
            ev=etx[,j]   # exposure
            beta3v[j]=llmaxM2C(beta1v[j],beta2v[j],beta3v[j],
                                kappa2v,gamma3v[(n+1-j):(n+m-j)],dv,ev,wv=wa[,j])
        }

        # calculate some inputs for applying the constraints
	  sa1=mtx*0
	  sa2=sa1
        for(i in 1:m)
        {
            sa1[i,]=gamma3v[(n+i-1):i]*wa[i,]
            sa2[i,]=wa[i,]
        }		 

        # Apply the constraints to normalise the parameter estimates
        fac21=mean(kappa2v)	   # use to ensure sum(t) kappa2(t)=0
        fac31=sum(sa1)/sum(sa2)  # ensures that sum(t,x) gamma3(t-x)=0
        fac22=1/sum(beta2v)
        fac32=1/sum(beta3v)
        beta1v=beta1v+beta2v*fac21+beta3v*fac31
        beta2v=beta2v*fac22
        beta3v=beta3v*fac32
        kappa2v=(kappa2v-fac21)/fac22
        gamma3v=(gamma3v-fac31)/fac32

        # Next few lines calculate the fitted death rate, the standardised
        # errors and the log-likelihood
	  mhat=mtx*0
        for(i in 1:m)
        {
            mhat[i,]=exp(beta1v+beta2v*kappa2v[i]+beta3v*gamma3v[(n+i-1):i])
	  }
        epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)
        l1=sum((dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1))*wa)
        cat(l1,"\n")

        # Stage 1A optimise over the beta1(x)
        for(j in 1:n)
        {		 		 
            # cycle through the range of years
		wv=1  # can be set to a vector of weights
		 	# to e.g. exclude duff years
		wv=wa[,j]
		s1=sum(wv*dtx[,j])
		s2=sum(wv*etx[,j]*exp(beta2v[j]*kappa2v+beta3v[j]*gamma3v[(n+1-j):(n+m-j)]))
		beta1v[j]=log(s1)-log(s2)
        }
		 		 
        # Next few lines calculate the fitted death rate, the standardised
        # errors and the log-likelihood
	  mhat=mtx*0
	  for(i in 1:m)
        {
            mhat[i,]=exp(beta1v+beta2v*kappa2v[i]+beta3v*gamma3v[(n+i-1):i])
	  }
        epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)
        l1=sum((dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1))*wa)
		 cat(l1,"->")

    }	 # end while loop


    # calculate number of parameters and deduct 4 for the number of constraints
    npar=length(beta1v)+length(beta2v)+length(beta3v)+length(kappa2v)+length(gamma3v)-4

    # Calculate the BIC
    BIC=l1-0.5*log(sum(wa))*npar

    list(beta1=beta1v,beta2=beta2v,beta3=beta3v,
          kappa2=kappa2v,gamma3=gamma3v,x=xv,y=yv,cy=cy,
          wa=wa,epsilon=epsilon,mhat=mhat,ll=l1,BIC=BIC,npar=npar)		 
}




fit703=function(xv,yv,etx,dtx,wa){
# Model M3
# Currie 3-factor APC model
# log m(t,x) = beta1(x) + kappa2(t) + gamma3(t-x) + Poisson error
# Renshaw-Haberman Model M2 with beta2(x)=1 and beta3(x)=1 for all x

# Inputs:
#   xv = vector of ages, length n
#   yv = vector of years, length m
#   etx = m x n matrix of exposures
#   dtx = m x n matrix of deaths
#   wa = m x n matrix of weights (0 or 1)

    mtx=dtx/etx	   # matrix of death rates
    qtx=1-exp(-mtx)  # matrix of mortality rates

    if(max(xv) > 89)
    { 
        cat("Upper age too high - suggest abort programme\n") 
    }

    n=length(xv)		 # number of ages
    m=length(yv)		 # number of years

    cy=(yv[1]-xv[n]):(yv[m]-xv[1])		 # cohort approximate years of birth
    beta1v=(1:n)*0
    beta2v=(1:n)*0+1		 # this will remain constant
    beta3v=(1:n)*0+1		 # this will remain constant
    kappa2v=(1:m)*0
    gamma3v=(1:(n+m-1))*0		 
    ia=array((1:m),c(m,n))	 # matrix of year indexes, i, for the data
    ja=t(array((1:n),c(n,m)))  # matrix of age indexes, j, for the data
    ya=ia-ja		 	 # matrix of year of birth indexes for the data
    imj=(1-n):(m-1)		 # the range of values taken by i-j
    lg=n+m-1		 	 # number of different values taken by i-j
    ca=ya+yv[1]-xv[1]		 # matrix of years of birth

    # Now set weights to zero for cohorts with fewer than 5 observations
    for(k in 1:lg)
    {
        nk=sum((ca == cy[k])*wa)
        if(nk < 5)
        {
            wa=wa*(1- (ca == cy[k]))
        }
    }

    ww=cy*0+1  # this is a vector of 1's and 0's with
		   # a 0 if the cohort is completely excluded
    for(k in 1:lg)
    {
        ww[k]=ww[k]*(sum((ca == cy[k])*wa) > 0)
    }

    # Stage 0
    # Gives initial estimates for beta1(x), beta2(x) and kappa2(t)
    mx=mean(xv)
    for(j in 1:n)
    {
        beta1v[j]=sum(log(mtx[,j])*wa[,j])/sum(wa[,j])
	  beta2v[j]=1/n	# fixed in this model
	  beta3v[j]=1/n	# fixed in this model
    }
    beta1vbar=beta1v
    kappa2v=(m:1)-(m+1)/2

    # Stage 1: iterations
    l0=-1000000
    l1=-999999
    # l1 is the latest estimate of the log-likelihood
    # l0 is the previous estimate
    # we continue to iterate if the improvement in log-likelihood
    # exceeds 0.0001
    while(abs(l1-l0) > 0.0001)
    {
        l0=l1

        # Stage 1D optimise over the kappa2(t)
	  for(i in 1:m)
        {		 		 
            # cycle through the range of years
		dv=dtx[i,]	# actual deaths
		ev=etx[i,]	# exposure
		kappa2v[i]=llmaxM2D(beta1v,beta2v,beta3v,kappa2v[i],gamma3v[(n+i-1):i],dv,ev,wv=wa[i,])
        }

        mhat=mtx*0
	  for(i in 1:m)
        {
            mhat[i,]=exp(beta1v+beta2v*kappa2v[i]+beta3v*gamma3v[(n+i-1):i])
	  }
        epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)
        l1=sum((dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1))*wa)
		 cat(l1,"->")

        # Stage 1E optimises over the gamma3(t-x)
	  for(k in 1:lg)
        {
            if(ww[k] == 0)
            { 
                gamma3v[k]=0 
            }
		else 
            {
		 		 
                id=0+(ya == imj[k])	# pick out entries with a specific year of birth
		    ny=sum(id)		# number of entries in matrix with this year of birth
		    nvt=1:(n*m)
		    nvk=order(-id)[1:ny]
		    iiv=ia[nvk]
		    jjv=ja[nvk]
		    dv=dtx[nvk]
		    ev=etx[nvk]
		    wv=wa[nvk]
		    gamma3v[k]=llmaxM2E(beta1v[jjv],beta2v[jjv],beta3v[jjv],
                                     kappa2v[iiv],gamma3v[k],dv,ev,wv=wv)
		    if(gamma3v[k] > 100)
                { 
                    gamma3v[k]=100 
                }
		    if(gamma3v[k] < -100)
                { 
                     gamma3v[k]=-100 
                }
            }  # end of calculations for normal cohorts
        }

        # Set up some variables for use in the constraints
	  sa1=mtx*0
	  sa2=sa1
	  for(i in 1:m)
        {
            sa1[i,]=gamma3v[(n+i-1):i]*wa[i,]
	      sa2[i,]=wa[i,]
        }		 

        # apply the constraints
	  fac21=mean(kappa2v)
	  fac31=sum(sa1)/sum(sa2)  # ensures that sum(t,x) gamma3(t-x)=0
	  beta1v=beta1v+beta2v[1]*fac21+beta3v[1]*fac31
	  kappa2v=kappa2v-fac21
	  gamma3v=gamma3v-fac31
	  s1=sum((xv-mx)*(beta1v-beta1vbar))
	  s2=sum((xv-mx)^2)
	  delta=-s1/s2
	  beta1v=beta1v+delta*(xv-mx)/n
	  kappa2v=kappa2v-delta*(yv-mean(yv))
	  gamma3v=gamma3v+delta*(cy-mean(yv)+mx)

        # estimated death rates, log-likelihood
	  mhat=mtx*0
	  for(i in 1:m)
        {
            mhat[i,]=exp(beta1v+beta2v*kappa2v[i]+beta3v*gamma3v[(n+i-1):i])
	  }
        epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)
        l1=sum((dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1))*wa)
	  cat(l1," ->")

        # Stage 1A optimise over the beta1(x)
	  for(j in 1:n)
        {
            # cycle through the range of years
		wv=1	# can be set to a vector of weights
		 	# to e.g. exclude duff years
		wv=wa[,j]
		s1=sum(wv*dtx[,j])
		s2=sum(wv*etx[,j]*exp(beta2v[j]*kappa2v+beta3v[j]*gamma3v[(n+1-j):(n+m-j)]))
		beta1v[j]=log(s1)-log(s2)
        }
		 		 
        mhat=mtx*0
        for(i in 1:m)
        {
            mhat[i,]=exp(beta1v+beta2v*kappa2v[i]+beta3v*gamma3v[(n+i-1):i])
	  }
	  epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)
	  l1=sum((dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1))*wa)
	  cat(l1,"\n")

    
    }  # end while loop


    # calculate number of parameters and deduct 4 for the number of constraints
    npar=length(beta1v)+length(kappa2v)+length(gamma3v)-3

    # Calculate the BIC
    BIC=l1-0.5*log(sum(wa))*npar

    list(beta1=beta1v,beta2=beta2v,beta3=beta3v,
          kappa2=kappa2v,gamma3=gamma3v,x=xv,y=yv,cy=cy,
          wa=wa,epsilon=epsilon,mhat=mhat,ll=l1,BIC=BIC,npar=npar)		 
}



fit705=function(xv,yv,etx,dtx,wa){
# Model M5
# CBD Model: 2-factor model published in JRI Dec, 2006
# logit q(t,x) = A1(t)+A2(t)(x-xbar) + Poisson error

# Inputs:
#   xv = vector of ages, length n
#   yv = vector of years, length m
#   etx = m x n matrix of exposures
#   dtx = m x n matrix of deaths
#   wa = m x n matrix of weights (0 or 1)

    mx=mean(xv)
    mx2=mean((xv-mx)^2)
    mtx=dtx/etx	   # matrix of death rates
    qtx=1-exp(-mtx)  # matrix of mortality rates

    if(max(xv) > 89)
    { 
        cat("Upper age too high - suggest abort programme\n") 
    }

    n=length(xv)  # number of ages
    m=length(yv)  # number of years

    cy=(yv[1]-xv[n]):(yv[m]-xv[1])	# cohort approximate years of birth
    # initialise the parameter vectors
    kappa1v=(1:m)*0
    kappa2v=kappa1v
    kappa4v=kappa1v		 # dummy vector, stays at 0
    beta2v=(xv-mx)
    beta4v=(xv-mx)^2-mx2	 # irrelevant if kappa4 stays at 0
    beta3v=xv*0+1		 	 # irrelevant if gamma3 stays at 0
    gamma3v=(1:(n+m-1))*0	 # dummy vector, stays at 0
    ia=array((1:m),c(m,n))	 # matrix of year indexes, i, for the data
    ja=t(array((1:n),c(n,m)))  # matrix of age indexes, j, for the data
    ya=ia-ja		 	 # matrix of year of birth indexes for the data
    imj=(1-n):(m-1)		 # the range of values taken by i-j
    lg=n+m-1		 	 # number of different values taken by i-j
    ca=ya+yv[1]-xv[1]		 # matrix of years of birth

    # Now set weights to zero for cohorts with fewer than 5 observations
    for(k in 1:lg)
    {
        nk=sum((ca == cy[k])*wa)
	  if(nk < 5)
        {
            wa=wa*(1- (ca == cy[k]))
	  }
    }

    ww=cy*0+1  # this is a vector of 1's and 0's with
		   # a 0 if the cohort is completely excluded
    for(k in 1:lg)
    {
        ww[k]=ww[k]*(sum((ca == cy[k])*wa) > 0)
    }

    # Stage 0
    # Least squares estimates for kappa1(t) and kappa2(t)
    for(i in 1:m)
    {
        qv=logit(qtx[i,]*wa[i,]+0.5*(1-wa[i,]))
        alpha=sum(qv*wa[i,])/sum(wa[i,])
        beta=sum((qv-alpha)*(xv-mx)*wa[i,])/sum((xv-mx)^2*wa[i,])
	  kappa2v[i]=beta
	  kappa1v[i]=alpha
    }

    # Stage 1 
    # Full MLE, iterative
    iter=0
    l0=-1000000
    l1=-999999
    # l1 is the latest estimate of the log-likelihood
    # l0 is the previous estimate
    # we continue to iterate if the improvement in log-likelihood
    # exceeds 0.0001

    while(l1-l0 > 0.0001)
    {
        l0=l1

        # Stage 1A: optimise the kappa1(t) and kappa2(t) sequentially 
	  for(i in 1:m)
        {		 		 
            # cycle through the range of years
		dv=dtx[i,]	# actual deaths
		ev=etx[i,]	# exposure
		wv=wa[i,]
		kappa1v[i]=llmaxM7A(kappa1v[i],kappa2v[i],kappa4v[i],
                                 beta2v,beta3v,beta4v,gamma3v[(n+i-1):i],dv,ev,wv=wv)
		kappa2v[i]=llmaxM7B(kappa1v[i],kappa2v[i],kappa4v[i],
                                 beta2v,beta3v,beta4v,gamma3v[(n+i-1):i],dv,ev,wv=wv)
        }		 		 
		 		 
        # now calculate the current estimate of m(t,x)
        # and calculate standardised errors and the log-likelihood
	  mhat=mtx*0
	  for(i in 1:m)
        {
            g3=gamma3v[(n+i-1):i]
            mhat[i,]=log(1+exp(kappa1v[i]+kappa2v[i]*beta2v+g3))
	  }

	  epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)
	  l1=sum(wa*(dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1)))
	  cat(l1,"\n")

    }	 # end while loop

    # calculate number of parameters and deduct the number of constraints (if any)
    # here 0 constraints
    npar=length(kappa1v)+length(kappa2v) -0

    # Calculate the BIC
    # sum(wa) is the number of observations used in the estimation procedure
    BIC=l1-0.5*log(sum(wa))*npar

    x0=0
    list(kappa1=kappa1v,kappa2=kappa2v,kappa4=kappa4v,
          beta2=beta2v,beta3=beta3v,beta4=beta4v,gamma3=gamma3v,x0=x0,x=xv,y=yv,cy=cy,
          epsilon=epsilon,mhat=mhat,mtx=mtx,npar=npar,ll=l1,BIC=BIC,wa=wa)		 
}




fit706=function(xv,yv,etx,dtx,wa,fix.g3=0){
# Model M6
# As model M8 but beta3(x)=1 rather than x0-x
# CBD Model: 3-factor APC model 
# logit q(t,x) = A1(t)+A2(t)(x-xbar) +A3(t-x) + Poisson error

# Inputs:
#   xv = vector of ages, length n
#   yv = vector of years, length m
#   etx = m x n matrix of exposures
#   dtx = m x n matrix of deaths
#   wa = m x n matrix of weights (0 or 1)
#   if wa = -1 default is assumed then wa is set
#    up below as a matrix of 1's

    mx=mean(xv)
    mx2=mean((xv-mx)^2)
    mtx=dtx/etx	   # matrix of death rates
    qtx=1-exp(-mtx)  # matrix of mortality rates

    if(max(xv) > 89)
    { 
        cat("Upper age too high - suggest abort programme\n") 
    }

    n=length(xv)	# number of ages
    m=length(yv)	# number of years

    cy=(yv[1]-xv[n]):(yv[m]-xv[1])  # cohort approximate years of birth
    # initialise the parameter vectors
    kappa1v=(1:m)*0
    kappa2v=kappa1v
    kappa4v=kappa1v		 # dummy vector, stays at 0
    beta2v=(xv-mx)
    beta4v=(xv-mx)^2-mx2	 # irrelevant if kappa4 stays at 0
    beta3v=xv*0+1
    gamma3v=(1:(n+m-1))*0
    ia=array((1:m),c(m,n))	 # matrix of year indexes, i, for the data
    ja=t(array((1:n),c(n,m)))	 # matrix of age indexes, j, for the data
    ya=ia-ja		 	 # matrix of year of birth indexes for the data
    imj=(1-n):(m-1)		 # the range of values taken by i-j
    lg=n+m-1		 	 # number of different values taken by i-j
    ca=ya+yv[1]-xv[1]		 # matrix of years of birth

    # Now set weights to zero for cohorts with fewer than 5 observations
    for(k in 1:lg)
    {
        nk=sum((ca == cy[k])*wa)
	  if(nk < 5)
        {
            wa=wa*(1- (ca == cy[k]))
	  }
    }

    ww=cy*0+1  # this is a vector of 1's and 0's with
		   # a 0 if the cohort is completely excluded
    for(k in 1:lg)
    {
        ww[k]=ww[k]*(sum((ca == cy[k])*wa) > 0)
    }
    ww1=order(-ww)[1]
    ww2=length(ww)+1-order(-ww[length(ww):1])[1]
    ww3=floor((ww1+ww2)/2)

    # Stage 0
    # Least squares estimates for kappa1(t) and kappa2(t)
    # Gives initial estimates for kappa1(t) and kappa2(t) assuming gamma3(t-x)=0
    for(i in 1:m)
    {
        qv=logit(qtx[i,])
        alpha=mean(qv)
        beta=sum((qv-alpha)*(xv-mx))/sum((xv-mx)^2)
        kappa2v[i]=beta
        kappa1v[i]=alpha
        kappa4v[i]=0
    }

    # Stage 1 
    # Full MLE, iterative
    iteration=0
    l0=-1000000
    l1=-999999
    # l1 is the latest estimate of the log-likelihood
    # l0 is the previous estimate
    # we continue to iterate if the improvement in log-likelihood
    # exceeds 0.0001
    while(l1-l0 > 0.0001)
    {
        iteration=iteration+1
        l0=l1

        # Begin the calculations to apply the three constraints
        g3=gamma3v[ww1:ww2]
	  cy3=cy[ww1:ww2]
	  mm=mean(cy3+mx)
	  s11=length(g3)
	  s12=sum((cy3+mx-mm)^1)
	  s13=sum((cy3+mx-mm)^2)
	  s21=sum((cy3+mx-mm)^1)
	  s22=sum((cy3+mx-mm)^2)
	  s23=sum((cy3+mx-mm)^3)
	  s31=sum((cy3+mx-mm)^2)
	  s32=sum((cy3+mx-mm)^3)
	  s33=sum((cy3+mx-mm)^4)
	  t1=sum(g3)
	  t2=sum(g3*(cy3+mx-mm))
	  t3=sum(g3*(cy3+mx-mm)^2)
	  ss=array(c(s11,s21,s12,s22),c(2,2))
	  tt=array(c(t1,t2),c(2,1))
	  phi=(solve(ss) %*% tt)[,1]
	  phi3=phi[1]-phi[2]*mm
	  phi4=phi[2]

        # apply the three constraints simultaneously
	  gamma3v=gamma3v-phi3-phi4*(cy+mx)
	  kappa1v=kappa1v+phi3+phi4*yv
	  kappa2v=kappa2v-phi4

        # now calculate the current estimate of m(t,x)
        # and calculate standardised errors and the log-likelihood
	  mhat=mtx*0
	  for(i in 1:m)
        {
            g3=gamma3v[(n+i-1):i]
		mhat[i,]=log(1+exp(kappa1v[i]+kappa2v[i]*beta2v+kappa4v[i]*beta4v+g3*beta3v))
	  }

	  epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)  # matrix of standardised errors
	  l1=sum(wa*(dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1)))
	  cat(l1," --> ")

        # Stage 1A: optimise the kappa1(t), kappa2(t) and kappa4(t) sequentially 
        # 		  given the latest estimates and gamma3(t-x) and x0
	  for(i in 1:m)
        {		 		 
            # cycle through the range of years
		dv=dtx[i,]	# actual deaths
		ev=etx[i,]	# exposure
		wv=wa[i,]
		kappa1v[i]=llmaxM7A(kappa1v[i],kappa2v[i],kappa4v[i],
                                 beta2v,beta3v,beta4v,gamma3v[(n+i-1):i],dv,ev,wv=wv)
		kappa2v[i]=llmaxM7B(kappa1v[i],kappa2v[i],kappa4v[i],
                                 beta2v,beta3v,beta4v,gamma3v[(n+i-1):i],dv,ev,wv=wv)
	  }


        # now calculate the current estimate of m(t,x)
        # and calculate standardised errors and the log-likelihood
	  mhat=mtx*0
	  for(i in 1:m)
        {
            g3=gamma3v[(n+i-1):i]
		mhat[i,]=log(1+exp(kappa1v[i]+kappa2v[i]*beta2v+kappa4v[i]*beta4v+g3*beta3v))
	  }

        epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)  # matrix of standardised errors
        l1=sum(wa*(dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1)))
	  cat(l1," -> ")

        if(fix.g3 == 0)
        {
            # Stage 1C - estimate the gamma3(t-x) given the latest kappa1(t), kappa2(t), kappa4(t) and x0
            for(k in 1:lg)
            {
		    if(ww[k] == 0)
                { 
                    gamma3v[k]=0 
                }	  # skip this k if the cohort is not included
		    else 
                {
                    id=0+(ya == imj[k]) # pick out entries with a specific year of birth
		 	  ny=sum(id)	    # number of entries in matrix with this year of birth
		 	  nvt=1:(n*m)
		 	  nvk=order(-id)[1:ny]
		 	  iiv=ia[nvk]
		 	  jjv=ja[nvk]
		 	  dv=dtx[nvk]
		 	  ev=etx[nvk]
		 	  wv=wa[nvk]
		 	  gamma3v[k]=llmaxM7C(kappa1v[iiv],kappa2v[iiv],kappa4v[iiv],
                                        beta2v[jjv],beta3v[jjv],beta4v[jjv],gamma3v[k],dv,ev,wv=wv)
		     }
		 }
        } # end of gamma3 updating if required

        # now calculate the current estimate of m(t,x)
        # and calculate standardised errors and the log-likelihood
	  mhat=mtx*0
	  for(i in 1:m)
        {
            g3=gamma3v[(n+i-1):i]
		mhat[i,]=log(1+exp(kappa1v[i]+kappa2v[i]*beta2v+kappa4v[i]*beta4v+g3*beta3v))
	  }

        epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)  # matrix of standardised errors
        l1=sum(wa*(dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1)))
        cat(l1,"\n")


    }	  # end while loop

    # calculate number of parameters and deduct 3 for the number of constraints
    npar=length(kappa1v)+length(kappa2v)+length(gamma3v)-2

    # Calculate the BIC
    BIC=l1-0.5*log(sum(wa))*npar

    x0=0
    list(kappa1=kappa1v,kappa2=kappa2v,kappa4=kappa4v,
          beta2=beta2v,beta3=beta3v,beta4=beta4v,gamma3=gamma3v,x0=x0,x=xv,y=yv,cy=cy,
          epsilon=epsilon,mhat=mhat,mtx=mtx,npar=npar,ll=l1,BIC=BIC,wa=wa)		 
}



fit707=function(xv,yv,etx,dtx,wa,fix.g3=0){
# Model M7
# CBD Model: 3-factor APC model 
# logit q(t,x) = A1(t)+A2(t)(x-xbar)+A4(t)((x-xbar)^2-x2bar)+A3(t-x) + Poisson error

# Inputs:
#   xv = vector of ages, length n
#   yv = vector of years, length m
#   etx = m x n matrix of exposures
#   dtx = m x n matrix of deaths
#   wa = m x n matrix of weights (0 or 1)

    mx=mean(xv)
    mx2=mean((xv-mx)^2)
    mtx=dtx/etx	   # matrix of death rates
    qtx=1-exp(-mtx)  # matrix of mortality rates

    if(max(xv) > 89)
    { 
        cat("Upper age too high - suggest abort programme\n") 
    }

    n=length(xv)  # number of ages
    m=length(yv)  # number of years

    cy=(yv[1]-xv[n]):(yv[m]-xv[1])  # cohort approximate years of birth
    # initialise the parameter vectors
    kappa1v=(1:m)*0
    kappa2v=kappa1v
    kappa3v=kappa1v
    beta2v=(xv-mx)
    beta4v=(xv-mx)^2-mx2
    beta3v=xv*0+1
    gamma4v=(1:(n+m-1))*0
    ia=array((1:m),c(m,n))	 # matrix of year indexes, i, for the data
    ja=t(array((1:n),c(n,m)))  # matrix of age indexes, j, for the data
    ya=ia-ja		 	 # matrix of year of birth indexes for the data
    imj=(1-n):(m-1)		 # the range of values taken by i-j
    lg=n+m-1		 	 # number of different values taken by i-j
    ca=ya+yv[1]-xv[1]		 # matrix of years of birth

    # Now set weights to zero for cohorts with fewer than 5 observations
    for(k in 1:lg)
    {
        nk=sum((ca == cy[k])*wa)
	  if(nk < 5)
        {
            wa=wa*(1- (ca == cy[k]))
	  }
    }

    ww=cy*0+1  # this is a vector of 1's and 0's with
		   # a 0 if the cohort is completely excluded
    for(k in 1:lg)
    {
        ww[k]=ww[k]*(sum((ca == cy[k])*wa) > 0)
    }
    ww1=order(-ww)[1]
    ww2=length(ww)+1-order(-ww[length(ww):1])[1]
    ww3=floor((ww1+ww2)/2)

    # Stage 0
    # Least squares estimates for kappa1(t) and kappa2(t)
    # Gives initial estimates for kappa1(t) and kappa2(t) assuming gamma4(t-x)=0
    for(i in 1:m)
    {
        qv=logit(qtx[i,])
	  alpha=mean(qv)
	  beta=sum((qv-alpha)*(xv-mx))/sum((xv-mx)^2)
	  kappa2v[i]=beta
	  kappa1v[i]=alpha
	  kappa3v[i]=0
    }

    # Stage 1 
    # Full MLE, iterative
    iteration=0
    l0=-1000000
    l1=-999999
    # l1 is the latest estimate of the log-likelihood
    # l0 is the previous estimate
    # we continue to iterate if the improvement in log-likelihood
    # exceeds 0.0001
    while(l1-l0 > 0.0001)
    {
        iteration=iteration+1
	  l0=l1

        if(fix.g3 == 0)
        {
            # Begin the calculations to apply the three constraints
		g3=gamma4v[ww1:ww2]
		cy3=cy[ww1:ww2]
		mm=mean(cy3+mx)
		s11=length(g3)
		s12=sum((cy3+mx-mm)^1)
		s13=sum((cy3+mx-mm)^2)
		s21=sum((cy3+mx-mm)^1)
		s22=sum((cy3+mx-mm)^2)
		s23=sum((cy3+mx-mm)^3)
		s31=sum((cy3+mx-mm)^2)
		s32=sum((cy3+mx-mm)^3)
		s33=sum((cy3+mx-mm)^4)
		t1=sum(g3)
		t2=sum(g3*(cy3+mx-mm))
		t3=sum(g3*(cy3+mx-mm)^2)
		ss=array(c(s11,s21,s31,s12,s22,s32,s13,s23,s33),c(3,3))
		tt=array(c(t1,t2,t3),c(3,1))
		phi=(solve(ss) %*% tt)[,1]
		phi3=phi[1]-phi[2]*mm+phi[3]*mm^2
		phi4=phi[2]-2*phi[3]*mm
		phi5=phi[3]

            # apply the three constraints simultaneously
		gamma4v=gamma4v-phi3-phi4*(cy+mx)-phi5*((cy+mx)^2)
		kappa1v=kappa1v+phi3+phi4*yv+phi5*(yv^2-mx2)
		kappa2v=kappa2v-phi4-phi5*2*yv
		kappa3v=kappa3v+phi5
        } # end the application of constraints if gamma4v is being estimated


        # now calculate the current estimate of m(t,x)
        # and calculate standardised errors and the log-likelihood
	  mhat=mtx*0
	  for(i in 1:m)
        {
            g3=gamma4v[(n+i-1):i]
		mhat[i,]=log(1+exp(kappa1v[i]+kappa2v[i]*beta2v+kappa3v[i]*beta4v+g3*beta3v))
	  }

        epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)  # matrix of standardised errors
	  l1=sum(wa*(dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1)))
		 cat(l1," --> ")

        # Stage 1A: optimise the kappa1(t), kappa2(t) and kappa3(t) sequentially 
        # 		  given the latest estimates and gamma4(t-x) and x0
	  for(i in 1:m)
        {		 		 
            # cycle through the range of years
		dv=dtx[i,]	# actual deaths
		ev=etx[i,]	# exposure
		wv=wa[i,]
		kappa1v[i]=llmaxM7A(kappa1v[i],kappa2v[i],kappa3v[i],
                                 beta2v,beta3v,beta4v,gamma4v[(n+i-1):i],dv,ev,wv=wv)
		kappa2v[i]=llmaxM7B(kappa1v[i],kappa2v[i],kappa3v[i],
                                 beta2v,beta3v,beta4v,gamma4v[(n+i-1):i],dv,ev,wv=wv)
		kappa3v[i]=llmaxM7D(kappa1v[i],kappa2v[i],kappa3v[i],
                                 beta2v,beta3v,beta4v,gamma4v[(n+i-1):i],dv,ev,wv=wv)		 		 
        }


        # now calculate the current estimate of m(t,x)
        # and calculate standardised errors and the log-likelihood
	  mhat=mtx*0
	  for(i in 1:m)
        {
            g3=gamma4v[(n+i-1):i]
		mhat[i,]=log(1+exp(kappa1v[i]+kappa2v[i]*beta2v+kappa3v[i]*beta4v+g3*beta3v))
        }

        epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)	# matrix of standardised errors
        l1=sum(wa*(dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1)))
		 cat(l1," -> ")

        if(fix.g3 == 0)
        {
            # Stage 1C - estimate the gamma4(t-x) given the latest kappa1(t), kappa2(t), kappa3(t) and x0

            for(k in 1:lg)
            {
		    if(ww[k] == 0)
                { 
                    gamma4v[k]=0 
                }	 # skip this k if the cohort is not included
		    else 
                {
                    id=0+(ya == imj[k])  # pick out entries with a specific year of birth
		 	  ny=sum(id)	     # number of entries in matrix with this year of birth
		 	  nvt=1:(n*m)
		 	  nvk=order(-id)[1:ny]
		 	  iiv=ia[nvk]
		 	  jjv=ja[nvk]
		 	  dv=dtx[nvk]
		 	  ev=etx[nvk]
		 	  wv=wa[nvk]
		 	  gamma4v[k]=llmaxM7C(kappa1v[iiv],kappa2v[iiv],kappa3v[iiv],
                                         beta2v[jjv],beta3v[jjv],beta4v[jjv],gamma4v[k],dv,ev,wv=wv)
		     }
		 }
        } # end of gamma4 updating if required

        # now calculate the current estimate of m(t,x)
        # and calculate standardised errors and the log-likelihood
	  mhat=mtx*0
	  for(i in 1:m)
        {
            g3=gamma4v[(n+i-1):i]
		mhat[i,]=log(1+exp(kappa1v[i]+kappa2v[i]*beta2v+kappa3v[i]*beta4v+g3*beta3v))
	  }

	  epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)  # matrix of standardised errors
	  l1=sum(wa*(dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1)))
	  cat(l1,"\n")

    }  # end while loop

    # calculate number of parameters and deduct 3 for the number of constraints
    npar=length(kappa1v)+length(kappa2v)+length(kappa3v)+(1-fix.g3)*(length(gamma4v)-3)

    # Calculate the BIC
    BIC=l1-0.5*log(sum(wa))*npar

    x0=0
   list(kappa1=kappa1v,kappa2=kappa2v,kappa3=kappa3v,
        beta2=beta2v,beta3=beta3v,beta4v=beta4v,gamma4=gamma4v,x0=x0,x=xv,y=yv,cy=cy,
        epsilon=epsilon,mhat=mhat,mtx=mtx,npar=npar,ll=l1,BIC=BIC,wa=wa)		 
}




fit708=function(xv,yv,etx,dtx,wa,x0=75,fix.x0=0){
# Model M8
# CBD Model: 3-factor APC model 
# logit q(t,x) = A1(t)+A2(t)(x-xbar)+A3(t-x)(x0-x) + Poisson error

# Inputs:
#   xv = vector of ages, length n
#   yv = vector of years, length m
#   etx = m x n matrix of exposures
#   dtx = m x n matrix of deaths
#   wa = m x n matrix of weights (0 or 1)
#   fix.x0 tells us whether or not we want to optimise
#		 		 over x0 in beta3(x)=(x0-xv)

    mx=mean(xv)
    mx2=mean((xv-mx)^2)
    mtx=dtx/etx	   # matrix of death rates
    qtx=1-exp(-mtx)  # matrix of mortality rates

    if(max(xv) > 89)
    { 
        cat("Upper age too high - suggest abort programme\n") 
    }

    n=length(xv)  # number of ages
    m=length(yv)  # number of years

    cy=(yv[1]-xv[n]):(yv[m]-xv[1])  # cohort approximate years of birth
    # initialise the parameter vectors
    kappa1v=(1:m)*0
    kappa2v=kappa1v
    kappa4v=kappa1v		 # dummy vector will stay at 0
    beta2v=(xv-mx)
    beta3v=x0-xv
    beta4v=(xv-mx)^2-mx2	 # not relevant when kappa4=0
    gamma3v=(1:(n+m-1))*0
    ia=array((1:m),c(m,n))	 # matrix of year indexes, i, for the data
    ja=t(array((1:n),c(n,m)))	 # matrix of age indexes, j, for the data
    ya=ia-ja		 	 # matrix of year of birth indexes for the data
    imj=(1-n):(m-1)		 # the range of values taken by i-j
    lg=n+m-1		 	 # number of different values taken by i-j
    ca=ya+yv[1]-xv[1]		 # matrix of years of birth

    # Now set weights to zero for cohorts with fewer than 5 observations
    for(k in 1:lg)
    {
        nk=sum((ca == cy[k])*wa)
        if(nk < 5)
        {
            wa=wa*(1- (ca == cy[k]))
	  }
    }

		 ww=cy*0+1		 # this is a vector of 1's and 0's with
		 		 		 # a 0 if the cohort is completely excluded
		 for(k in 1:lg){
		 		 ww[k]=ww[k]*(sum((ca == cy[k])*wa) > 0)
		 }

    # Stage 0
    # Least squares estimates for kappa1(t) and kappa2(t)
    # Gives initial estimates for kappa1(t) and kappa2(t) assuming gamma3(t-x)=0
    for(i in 1:m)
    {
        qv=logit(qtx[i,])
	  alpha=mean(qv)
	  beta=sum((qv-alpha)*(xv-mx))/sum((xv-mx)^2)
	  kappa2v[i]=beta
	  kappa1v[i]=alpha
    }

    # Stage 1 
    # Full MLE, iterative
    iteration=0
    l0=-1000000
    l1=-999999
    # l1 is the latest estimate of the log-likelihood
    # l0 is the previous estimate
    # we continue to iterate if the improvement in log-likelihood
    # exceeds 0.0001
    while(l1-l0 > 0.0001)
    {
        iteration=iteration+1
	  l0=l1

        # Stage 1C - estimate the gamma3(t-x) given the latest kappa1(t) and kappa2(t) and x0

	  for(k in 1:lg)
        {
            if(ww[k] == 0)
            { 
                gamma3v[k]=0 
            }  # skip this k if the cohort is not included
		else 
            {
                id=0+(ya == imj[k])  # pick out entries with a specific year of birth
		    ny=sum(id)		 # number of entries in matrix with this year of birth
		    nvt=1:(n*m)
		    nvk=order(-id)[1:ny]
		    iiv=ia[nvk]
		    jjv=ja[nvk]
		    dv=dtx[nvk]
		    ev=etx[nvk]
		    wv=wa[nvk]
		    gamma3v[k]=llmaxM7C(kappa1v[iiv],kappa2v[iiv],kappa4v[iiv],
                                     beta2v[jjv],beta3v[jjv],beta4v[jjv],gamma3v[k],dv,ev,wv=wv)
		 }
        }

        # calculate some statistics to be used in the application
        # of the constraints
	  sa1=mtx*0
	  sa2=sa1
	  for(i in 1:m)
        {
            sa1[i,]=gamma3v[(n+i-1):i]*wa[i,]
		sa2[i,]=wa[i,]
	  }		 

        # Apply the one constraint
        fac31=sum(sa1)/sum(sa2)  # ensures that sum(t,x) beta3(x) * gamma3(t-x)=0
	  kappa2v=(kappa2v-fac31)
	  gamma3v=(gamma3v-fac31)
	  kappa1v=kappa1v+fac31*(x0-mx)
	  for(k in 1:lg)
        {
            if(ww[k] == 0){ gamma3v[k]=0 }
	  }

        # now calculate the current estimate of m(t,x)
        # and calculate standardised errors and the log-likelihood
	  mhat=mtx*0
	  for(i in 1:m)
        {
            g3=gamma3v[(n+i-1):i]
		mhat[i,]=log(1+exp(kappa1v[i]+kappa2v[i]*beta2v+g3*beta3v))
	  }
	  epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)  # matrix of standardised errors
	  l1=sum(wa*(dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1)))
	  cat(l1," --> ")

        # Stage 1A: optimise the kappa1(t) and kappa2(t) sequentially 
        # 		 		 given the latest estimates and gamma3(t-x) and x0
	  for(i in 1:m)
        {	# cycle through the range of years
            dv=dtx[i,]		 # actual deaths
		ev=etx[i,]		 # exposure
		wv=wa[i,]
		kappa1v[i]=llmaxM7A(kappa1v[i],kappa2v[i],kappa4v[i],
                                 beta2v,beta3v,beta4v,gamma3v[(n+i-1):i],dv,ev,wv=wv)
		kappa2v[i]=llmaxM7B(kappa1v[i],kappa2v[i],kappa4v[i],
                                 beta2v,beta3v,beta4v,gamma3v[(n+i-1):i],dv,ev,wv=wv)
        }

        # Below: skip the next step if fix-x0 = 1
        if(fix.x0 == 0)
        {
            # Stage 1D optimise over x0 (=> beta3(x)) 
		x0=llmaxM7F(x0,kappa1v,kappa2v,kappa4v,beta2v,beta4v,gamma3v,dtx=dtx,etx=etx,xv=xv,wa=wa)
		beta3v=(x0-xv)

        }  # end of optimise over x0.

        # now calculate the current estimate of m(t,x)
        # and calculate standardised errors and the log-likelihood
	  mhat=mtx*0
	  for(i in 1:m)
        {
            g3=gamma3v[(n+i-1):i]
		mhat[i,]=log(1+exp(kappa1v[i]+kappa2v[i]*beta2v+g3*beta3v))
	  }
	  epsilon=(dtx-etx*mhat)/sqrt(etx*mhat)  # matrix of standardised errors
	  l1=sum(wa*(dtx*log(etx*mhat)-etx*mhat-lgamma(dtx+1)))
	  cat(l1,"\n")

    }	 # end while loop

    # calculate number of parameters and deduct 1 for the number of constraints
    npar=length(kappa1v)+length(kappa2v)+length(gamma3v)+(1-fix.x0)-1

    # Calculate the BIC
    BIC=l1-0.5*log(sum(wa))*npar

    list(kappa1=kappa1v,kappa2=kappa2v,kappa4=kappa4v,
          beta2=beta2v,beta3=beta3v,beta4=beta4v,gamma3=gamma3v,x0=x0,x=xv,y=yv,cy=cy,
          epsilon=epsilon,mhat=mhat,mtx=mtx,npar=npar,ll=l1,BIC=BIC,wa=wa)		 
}



llmaxM2B=function(b1,b2,b3,k2,g3,dv,ev,wv=1){
#   b1,b3,k2,g3 are given
#   solve for b2
    b21=b2
    b20=b21-1
    thetat=k2*ev*exp(b1+b3*g3)
    s1=sum(dv*k2*wv)
    while(abs(b21-b20) > 0.1)
    {
        b20=b21
        f0=sum((exp(b20*k2)*thetat)*wv)-s1
        df0=sum((exp(b20*k2)*k2*thetat)*wv)
		 		 b21=b20-f0/df0
    }
    b21
}

		 
llmaxM2C=function(b1,b2,b3,k2,g3,dv,ev,wv=1){
#   b1,b2,k2,g3 are given
#   solve for b3
    b31=b3
    b30=b31-1
    thetat=g3*ev*exp(b1+b2*k2)
    s1=sum(dv*g3*wv)
    while(abs(b31-b30) > 0.1)
    {
        b30=b31
        f0=sum((exp(b30*g3)*thetat)*wv)-s1
        df0=sum((exp(b30*g3)*g3*thetat)*wv)
        b31=b30-f0/df0
    }
    b31
}

		 
llmaxM2D=function(b1,b2,b3,k2,g3,dv,ev,wv=1){
#   b1,b2,b3,g3 are given
#   solve for k2
    k21=k2
    k20=k21-1
    thetat=b2*ev*exp(b1+b3*g3)
    s1=sum(dv*b2*wv)
    while(abs(k21-k20) > 0.1)
    {
        k20=k21
	  f0=sum((exp(k20*b2)*thetat)*wv)-s1
	  df0=sum((exp(k20*b2)*b2*thetat)*wv)
	  k21=k20-f0/df0
    }
    k21
}

		 

llmaxM2E=function(b1,b2,b3,k2,g3,dv,ev,wv=1){
#   b1,b2,b3,k2 are given
#   solve for g3
    g31=g3
    g30=g31-1
    thetat=b3*ev*exp(b1+b2*k2)
    s1=sum(dv*b3*wv)
    while(abs(g31-g30) > 0.1)
    {
        g30=g31
        f0=sum((exp(g30*b3)*thetat)*wv)-s1
	  df0=sum((exp(g30*b3)*b3*thetat)*wv)
	  g31=g30-f0/df0
    }
    g31
}


logit=function(x){ log(x/(1-x)) }


llmaxM7A=function(k1,k2,k4,b2,b3,b4,g3,dv,ev,wv=1){
# Optimise over kappa1(t) given kappa2(t), kappa4(t), beta2(x), beta3(x), beta4(x) and gamma3(t-x)
    h=0.000001
    mv=log(1+exp(k1+k2*b2+k4*b4+g3*b3))
    dm=1/(1+exp(-k1-k2*b2-k4*b4-g3*b3))
    f0=sum((dv/mv*dm-ev*dm)*wv)
    mvh=log(1+exp((k1+h)+k2*b2+k4*b4+g3*b3))
    dmh=1/(1+exp(-(k1+h)-k2*b2-k4*b4-g3*b3))
    f0h=sum((dv/mvh*dmh-ev*dmh)*wv)
    df0=(f0h-f0)/h
    k1new=k1-f0/df0
    k1new
}

llmaxM7B=function(k1,k2,k4,b2,b3,b4,g3,dv,ev,wv=1){
# Optimise over kappa2(t) given kappa1(t), kappa4(t), beta2(x), beta3(x), beta4(x) and gamma3(t-x)
    h=0.000001
    mv=log(1+exp(k1+k2*b2+k4*b4+g3*b3))
    dm=b2/(1+exp(-k1-k2*b2-k4*b4-g3*b3))
    f0=sum((dv/mv*dm-ev*dm)*wv)
    mvh=log(1+exp(k1+(k2+h)*b2+k4*b4+g3*b3))
    dmh=b2/(1+exp(-k1-(k2+h)*b2-k4*b4-g3*b3))
    f0h=sum((dv/mvh*dmh-ev*dmh)*wv)
    df0=(f0h-f0)/h
    k2new=k2-f0/df0
    k2new
}


llmaxM7D=function(k1,k2,k4,b2,b3,b4,g3,dv,ev,wv=1){
# Optimise over kappa4(t) given kappa1(t), kappa2(t), beta2(x), beta3(x), beta4(x) and gamma3(t-x)
    h=0.000001
    mv=log(1+exp(k1+k2*b2+k4*b4+g3*b3))
    dm=b4/(1+exp(-k1-k2*b2-k4*b4-g3*b3))
    f0=sum((dv/mv*dm-ev*dm)*wv)
    mvh=log(1+exp(k1+k2*b2+(k4+h)*b4+g3*b3))
    dmh=b4/(1+exp(-k1-k2*b2-(k4+h)*b4-g3*b3))
    f0h=sum((dv/mvh*dmh-ev*dmh)*wv)
    df0=(f0h-f0)/h
    k4new=k4-f0/df0
    k4new
}


llmaxM7C=function(k1,k2,k4,b2,b3,b4,g3,dv,ev,wv=1){
# Optimise over gamma3(t-x) given kappa1(t), kappa2(t), kappa4(t), beta2(x), beta3(x), beta4(x) 
    h=0.000001
    mv=log(1+exp(k1+k2*b2+k4*b4+g3*b3))
    dm=b3/(1+exp(-k1-k2*b2-k4*b4-g3*b3))
    f0=sum(wv*(dv/mv*dm-ev*dm))
    mvh=log(1+exp(k1+k2*b2+k4*b4+(g3+h)*b3))
    dmh=b3/(1+exp(-k1-k2*b2-k4*b4-(g3+h)*b3))
    f0h=sum(wv*(dv/mvh*dmh-ev*dmh))
    df0=(f0h-f0)/h
    g3new=g3-f0/df0
    g3new
}


llmaxM7F=function(x0,k1,k2,k4,b2,b4,g3,dtx,etx,xv,wa=1){
#   b2,b4,k1,k2,k4,g3 are given
#   solve for x0 which dictates the form of beta3
    x01=x0
    x00=x01-1000
    h=0.000001
    m=length(k1)
    n=length(b2)
    k1a=array(k1,c(m,n))
    k2a=array(k2,c(m,n))
    k4a=array(k4,c(m,n))
    b2a=t(array(b2,c(n,m)))
    b4a=t(array(b4,c(n,m)))
    b3=x0-xv
    b3a=t(array(b3,c(n,m)))
    g3a=b3a*0
    for(i in 1:m)
    {
        g3a[i,]=g3[(n+i-1):i]
    }
    while(abs(x01-x00) > 100)
    {
        x00=x01
	  mv=log(1+exp(k1a+k2a*b2a+k4a*b4a+g3a*b3a))
	  dm=g3a/(1+exp(-k1a-k2a*b2a-k4a*b4a-g3a*b3a))
	  f0=sum(wa*(dtx/mv*dm-etx*dm))
	  mvh=log(1+exp(k1a+k2a*b2a+k4a*b4a+g3a*(b3a+h)))
	  dmh=g3a/(1+exp(-k1a-k2a*b2a-k4a*b4a-g3a*(b3a+h)))
	  f0h=sum(wa*(dtx/mvh*dmh-etx*dmh))
	  df0=(f0h-f0)/h
	  x01=x00-f0/df0
    }
    x01
}



