# LifeMetrics Software 
# License Agreement
#
# This software license agreement (?Agreement?) is an agreement between JPMorgan Chase Bank, N.A.,
# (collectively with its affiliates, ?Morgan?) and you (either an individual or an entity on whose behalf the individual is acting) 
# (?you? or ?Licensee?) regarding your use of the LifeMetrics Software by JPMorgan and is effective on the date that you 
# either compile the Software Source Code or otherwise use the Products (?Agreement Effective Date?). 
#
# BEFORE YOU EITHER COMPILE THE SOFTWARE SOURCE CODE OR OTHERWISE USE THE PRODUCTS, CAREFULLY READ THE TERMS AND CONDITIONS 
# OF THIS AGREEMENT BELOW. BY COMPILING THE SOFTWARE SOURCE CODE OR USING THE PRODUCTS IN ANY MANNER, YOU ARE AGREEING TO BE 
# BOUND BY AND ARE BECOMING A PARTY TO THIS AGREEMENT. IF YOU DO NOT AGREE TO ALL OF THE TERMS OF THIS AGREEMENT, 
# IMMEDIATELY DELETE ALL COPIES OF THE PRODUCTS FROM YOUR COMPUTER SYSTEMS.
#
#	
# 1. Grant of License.
#
# (a) Subject to the terms and conditions of this Agreement, Morgan hereby grants to Licensee, a non-transferable, 
# non-assignable, personal, revocable, non-exclusive license: (i) to compile the source code of the LifeMetrics software 
# including all components and updates thereto, and to the proprietary data contained therein, (the ?Software Source Code?) 
# using a third party product, the results of which is the Software in object code form, (?Software Object Code?), 
# (?Software Source Code? and the ?Software Object Code? are hereinafter collectively referred to as the ?Software?), 
# and (ii) to use the Software to evaluate mortality projections, and (iii) to use any Software user manuals provided by Morgan, 
# (?Manuals?).  The ?Software? and the ?Manuals? are hereinafter referred to as ?Products?.
#
# (b) No rights to use the Products are granted hereunder other than those expressly granted in Section 1(a).  
# Except as expressly authorized in this Agreement, Licensee shall not rent, lease, sublicense, distribute, transfer, 
# copy, reproduce, display, modify or timeshare the Products or any portion thereof, or use the Products as a 
# component of or a base for products or services prepared for commercial or non commercial sale, sublicense, lease, 
# access, hosting, application service providing distribution outside the Licensee's organization, or prepare any derivative work
#  based on the Products. Licensee shall not allow any third party or unlicensed user or computer system to access or use the Products.  
# Licensee shall not reverse engineer, modify in any way, or create derivative works from the Products, or any portion thereof.  
# Licensee agrees that all improvements and modifications to the Products or any part thereof (whether developed by Morgan, 
# Licensee or any third party acting on behalf of them at any time shall be and remain the sole and exclusive property of Morgan.
#
# (c) A hyperlink to a software product provided by a third party that may be used to compile the Software Source Code 
# may be provided by Morgan (?Third Party Product?).  Morgan does not endorse or assume any responsibility or liability 
# with regards to the Third Party Product. 
#
# 2. Term; Termination.
#
# This Agreement commences on the Agreement Effective Date and expires twelve (12) months thereafter (?Term?).  
# Morgan may terminate this Agreement at any time for any reason upon thirty (30) days notice, provided, 
# however if Licensee breaches any material term of this Agreement, Morgan may terminate this Agreement immediately without any notice.
#
# 3. License fee.	
#	
# There is currently no license fee for the use of the Products hereunder.  
#
# 4. Ownership.
#
# Morgan retains all right, tile and interest to the Products (including any corrections, updates, adaptations, 
# enhancements or copies).  The Products are the confidential information of Morgan.  Licensee agrees to take all reasonable 
# steps to protect the Products from unauthorized copying or use.  
#
# 5. Representations, Warranties, Disclaimers, Indemnification.
#
# (a) Morgan and Licensee each represent and warrant as to itself that (i) it is duly organized, validly existing, 
# and in good standing under the laws of the jurisdiction of its organization or incorporation, (ii) it has the power to execute 
# the Agreement and to perform its obligations under the Agreement, and (iii) such execution and performance do not violate 
# or conflict with any law applicable to it,, any order or judgment of any court or other agency of government applicable to it 
# or any of its assets, or any contractual restriction binding on or affecting it or any of its assets.
#
# (b) EXCEPT AS SET FORTH IN THIS SECTION 6, MORGAN MAKES NO WARRANTY, REPRESENTATION, CONDITION, OR AGREEMENT 
# WITH RESPECT TO THE PRODUCT OR THE THIRD PARTY PRODUCT.  MORGAN EXPRESSLY DISCLAIMS AND EXCLUDES TO THE FULLEST EXTENT PERMITTED
# BY APPLICABLE LAW ANY AND ALL IMPLIED WARRANTIES, INCLUDING ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
# FOR THE PRODUCT AND THE THIRD PARTY PRODUCT.  MORGAN SHALL HAVE NO LIABILITY, CONTINGENT OR OTHERWISE, TO LICENSEE OR TO THIRD PARTIES, 
# FOR THE ACCURACY, COMPLETENESS OR CURRENCY OF THE PRODUCT OR THE THIRD PARTY PRODUCT OR FOR DELAYS OR OMISSIONS THEREIN, OR FOR INTERRUPTIONS 
# IN THE DELIVERY OF THE PRODUCT OR THE THIRD PARTY PRODUCT.  IN NO EVENT WILL MORGAN BE LIABLE FOR ANY DIRECT, ORDINARY, 
# SPECIAL, INDIRECT, INCIDENTAL AND/OR CONSEQUENTIAL DAMAGES WHICH MAY BE INCURRED OR EXPERIENCED BY LICENSEE AND/OR ANY 
# THIRD PARTIES INCLUDING BUT NOT LIMITED TO ON ACCOUNT OF LICENSEE ENTERING INTO AND/OR LICENSEE AND/OR ANY THIRD PARTY 
# RELYING ON THIS AGREEMENT, EVEN IF MORGAN HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 
#
# (c) Licensee shall indemnify, protect, and hold harmless Morgan, its affiliates, employees and agents, 
# from and against any and all losses, liabilities, judgments, suits, actions, proceedings, claims, damages, costs 
# (including reasonable attorney's fees) resulting from or arising out of the use by Licensee of the Products and/or the Third Party Product.
#
# 6. Injunctive Relief.
#
# Licensee acknowledges that a breach of any provision of this Agreement will cause Morgan party irreparable 
# injury and damage and therefore Licensee may be enjoined through injunctive proceedings in addition to any other rights 
# and remedies which may be available to Morgan at law or in equity without the posting of a bond.  
#
# 7. General.
#
# (a) All notices and other communications under this Agreement shall be in writing and deemed given upon receipt. 
# Notwithstanding the foregoing, Morgan may provide Licensee with notice by posting such Notice it Morgan?s Web site and 
# such notice shall be deemed valid in accordance with this Agreement.  Notice to Morgan shall be made to:  
# JPMorgan Chase Bank, N.A., Technology, Sourcing, and IP Practice Group, 25th Floor, 1 Chase Manhattan Plaza, New York, NY 10081, Fax:  212-383-0800.
#
# (b) The following sections shall survive termination of this Agreement: 4, 5, 6, and 7.
#
# (c) The Agreement constitutes the entire agreement and understanding of the parties with
# respect to its subject matter and supersedes all oral communications and prior writings with respect thereto.  
# Morgan may revise this Agreement by posting such revisions to its Web site and your continued use of the Products 
# shall constitute your acceptance of such new terms.
#
# (d) Licensee cannot assign this Agreement nor any interest or obligation in or under the Agreement without Morgan?s prior written consent.
#
# (e) Morgan will not be liable for any failure, delay or omission to perform any of its obligations 
# under the Agreement arising from any cause beyond its reasonable control, including, without limitation, acts of God, 
# acts or regulations of government or other authorities, war, fire, strikes or other industrial disputes, power failure, 
# failure of telecommunication lines, connection or equipment, or failure or defects in any hardware or software owned or supplied by third parties.
#
# (f) If any provision of the Agreement is held invalid, illegal or unenforceable, the validity, 
# legality or enforceability of the remainder of the Agreement will not in any way be affected or impaired thereby.
#
# (g) Licensee hereby agrees not to export or transmit the Products to any country to which such 
# transmission is restricted by applicable regulations or statutes.  Licensee agrees to permit Morgan access to 
# Licensee?s location where the Products is installed and/or used solely to permit Morgan to ensure compliance with the terms of this Agreement.
#
# (h) The Agreement will be governed by the laws of the State of New York without reference to choice of law principles. 
# Any action or proceeding relating to this Agreement may be brought and enforced in the courts of the State of New York 
# or the United States District Court located in the Borough of Manhattan in New York City. Each of the parties 
# irrevocably submits to the jurisdiction of such courts in connection with any such action or proceeding. 
# Any process or other legal summons in connection with any such action or proceeding may be served by mailing 
# a copy thereof by certified or registered mail, or any substantially similar form of mail, addressed to a party as provided 
# for notices hereunder. THE PARTIES WAIVE TRIAL BY JURY IN RESPECT OF ANY PROCEEDINGS RELATED TO THE AGREEMENT.



sim2001=function(xx,yy,beta1v,beta2v,kappa2v, mtxLastYear,nsim=100,tmax=20,nyears=0,x0=65, fixStartPoint=FALSE){
# Model M1

# This simulation does not include parameter uncertainty
# nsim is the number of sample paths to be generated
# tmax is the number of years forward that we project
# nyears is the number of years that we used to fit the random walk
# x0 is the initial age of a cohort in the final year 
# that will be projected forward

# inputs xx, yy, kappa1v, kappa2v are key outputs from fit705

# Note the difference between xx and xv defined below
# xx is the vector of ages used in the original fitting procedure
#		 and is used as the age range for projecting the 2-dimensional mortality table
# xv is the vector of ages of the cohort aged x0 in year 1:
#		 i.e. (x0, x0+1, x0+2, ...)

	set.seed(0)

  na=length(xx)  # xx=ages used in the fitting procedure
	ny=length(yy)  # yy=calendar years used in the fitting procedure

	k2=kappa2v
	if(fixStartPoint) {
		b1 = log(mtxLastYear)
	} else {
		b1=beta1v
	}
	b2=beta2v

	d2=diff(k2)	 # differences assumed to be i.i.d.
	m=length(d2)
	# nyears = number of years used to fit the random walk
	# if nyears=0 (default) then all years in data are used
	if(nyears == 0)
	{ 
	    nyears=m 
	}
	nv=(m-(nyears-1)):m		 # indexes of the last nyears observations
	mu2=mean(d2[nv])		 # mean over the last nyears observations
	v22=mean((d2[nv]-mu2)^2) # MLE for v22
	cc=sqrt(v22)		 	 # standard deviation

	n=length(k2)

    # tmax is the maximum number of years to follow the cohort
    xv=x0-1+(1:tmax)
    lx=length(xv)
	lxx=length(xx)
    ddv=array(0,c(1,lx))
    # Year 1 correponds to the final year in the sample
    # Hence the year 1 "simulated" value of kappa2 is k2[n]
    dd1=k2[n]
	# ddv is an 1 x lx array with each column being the 
	# values of (k2) over time in a given sample path
    ddv[,1]=dd1
    dda=array(0,c(1,lx,nsim+1))	  # stores the ddv results in a bigger array
		 		 		 		  # factor x year x scenario
    tpa=array(0,c(lx,nsim+1))		  # survivor index 
		 		 		 		  # year x scenario
	qaa=array(0,c(lxx,tmax,nsim+1)) # q(t,x) mortality rates for all simulations
		 		 		 		  # age x year x scenario
	qa=array(0,c(lxx,tmax))		  # q(t,x) mortality rates for one simulation
		 		 		 		  # age x year
    pa=tpa		 		 		  # one-year survival probabilities, all sims
		 		 		 		  # year x scenario

    # The Model 1 fitting procedure means that we have no automatic model for
    # mortality outside the age range of xx
    # We use here a crude method for extrapolating beta1 and beta2
    # However, at the end of the simulation loop we trim the 
    # x0 cohort projections (matrix tpa) back to stop at the maximum age xx[na]

    # How many extra ages are required to do the full cohort projection?
	extra.ages=max((x0+tmax-1)-xx[na],0)
    # now extrapolate b1 and b2 using a linear projection
	b1ext=c(b1[1:na-1],b1[na]+(b1[na]-b1[1])/(xx[na]-xx[1])*(0:extra.ages) )
	b2ext=c(b2[1:na-1],b2[na]+(b2[na]-b2[1])/(xx[na]-xx[1])*(0:extra.ages) )

    # Age indexes for the cohort over the projection
	nv.cohort=(x0-xx[1]+1):(x0-xx[1]+tmax)
	b1cohort=b1ext[nv.cohort]
	b2cohort=b2ext[nv.cohort]

    for(e in 1:(nsim+1))
    {   # nsim is the number of sample paths that
        # we want to simulate
	    # next loop simulates sample path in years 2 to lx
        for(f in 2:lx)
        {
		if ( e == 1)
			rz = 0
		else {
	            rz=rnorm(1)
		}

            ddv[,f]=ddv[,f-1]+mu2+cc*rz
        }
        dda[,,e]=ddv
        k2v=ddv[1,1:lx]
		if(fixStartPoint) {
	        dd1Vector = array(dd1, c(1, length(k2v)))
      	  mv = exp(b1cohort-b2cohort*(k2v - dd1Vector))
		} else {
	        mv=exp(b1cohort+b2cohort*k2v)
		}
        qv=1-exp(-mv)  # vector of mortality rates for this sample path
		 		 	   # and for the cohort initially aged x0
        pv=(1-qv)	   # convert into survival probabilities
        pa[,e]=pv	   # store in the summary matrix
        tpa[,e]=exp(cumsum(log(pv)))  # vector for the cohort survivor index

        # now do the qtx's by age xv[i]
		for(i in 1:lxx)
		{
			if(fixStartPoint) {
			   	mv0=exp(b1[i] + (b2[i]*(k2v-dd1)))
			} else {
			    	mv0=exp(b1[i]+b2[i]*k2v)
			}
        		qv0=1-exp(-mv0)
		    	qaa[i,,e]=qv0
		}
    }
    #  Now trim back the tpa matrix
	  n1=min(xx[na]-x0+1,tmax)
    pa=pa[1:n1,]
    tpa=tpa[1:n1,]

    list(y=yy[n]+(1:tmax)-1,xx=xx,xv=xv[1:n1],mu2=mu2,v22=v22,dda=dda,pa=pa,tpa=tpa,qaa=qaa)
}





# example simulations
# res101A is the result of fitting model M1 using fit701 with the full
# 44 year dataset
# we use the last 20 years though to estimate the random walk model

# res=sim2001(res101A$x,res101A$y,res101A$beta1,res101A$beta2,res101A$kappa2,nsim=1000,nyears=20,tmax=40,x0=60)
# fan(res$xv,res$tpa)		 		 # fan chart for cohort survival index
# fan(res$y,res$qaa[25,,])		 # fan chart for mortality rates at age xx[25]




sim2005=function(xx,yy,kappa1v,kappa2v,nsim=100,tmax=20,nyears=0,x0=65){
# Model M5

# This simulation does not include parameter uncertainty
# nsim is the number of sample paths to be generated
# tmax is the number of years forward that we project
# nyears is the number of years that we used to fit the random walk
# x0 is the initial age of a cohort in the final year 
# that will be projected forward

# inputs xx, yy, kappa1v, kappa2v are key outputs from fit705

# Note the difference between xx and xv defined below
# xx is the vector of ages used in the original fitting procedure
#		 and is used as the age range for projecting the 2-dimensional mortality table
# xv is the vector of ages of the cohort aged x0 in year 1:
#		 i.e. (x0, x0+1, x0+2, ...)

	set.seed(0)
    na=length(xx)	 # xx=ages used in the fitting procedure
    ny=length(yy)  # yy=calendar years used in the fitting procedure

    k1=kappa1v
    k2=kappa2v

    d1=diff(k1)  # (d1,d2)(t) differences assumed to be i.i.d.
    d2=diff(k2)
    m=length(d1)
    # nyears = number of years used to fit the random walk
    # if nyears=0 (default) then all years in data are used
    if(nyears == 0)
    { 
         nyears=m 
    }
    nv=(m-(nyears-1)):m		 # indexes of the last nyears observations
    mu1=mean(d1[nv])		 # means over the last nyears observations
    mu2=mean(d2[nv])
    v11=mean((d1[nv]-mu1)^2)		     # MLE for v11
    v12=mean((d1[nv]-mu1)*(d2[nv]-mu2))  # MLE for v12
    v21=v12		 		 	     # MLE for v21
    v22=mean((d2[nv]-mu2)^2)		     # MLE for v22
    vh=array(c(v11,v21,v12,v22),c(2,2))  # set up variance/cov. matrix
    cc=t(chol(vh))		 	     # cholesky decomposition of vh
    muh=c(mu1,mu2)		 	     # random walk drift vector		 

    n=length(k1)

    xbar=mean(xx)
    #	 y0=res$y[n]

    # tmax is the maximum number of years to follow the cohort
    xv=x0-1+(1:tmax)
    lx=length(xv)
    lxx=length(xx)
    ddv=array(0,c(2,lx))
    # Year 1 correponds to the final year in the sample
    # Hence the year 1 simulated values of kappa1 and kappa2 are k1[n], k2[n]
    dd1=c(k1[n],k2[n])
    # ddv is an lx by 2 array with each column being the 
    # values of (k1,k2) over time in a given sample path
    ddv[,1]=dd1
    dda=array(0,c(2,lx,nsim+1))	# stores the ddv results in a bigger array
		 		      # factor x year x scenario
    tpa=array(0,c(lx,nsim+1))   # survivor index 
		 		 	# year x scenario
    qaa=array(0,c(lxx,tmax,nsim+1))  # q(t,x) mortality rates for all simulations
		 		 	     # age x year x scenario
    qa=array(0,c(lxx,tmax))	     # q(t,x) mortality rates for one simulation
		 		 	     # age x year
    pa=tpa		 		     # one-year survival probabilities, all sims
		 		 	     # year x scenario
    for(e in 1:(nsim+1))
    {   # nsim is the number of sample paths that
        # we want to simulate
        # next loop simulates sample path in years 2 to lx
        for(f in 2:lx)
        {
		if ( e == 1)
			rz = array(1,c(2,1))
		else {
            	rz=rnorm(2)
            	rz=array(rz,c(2,1))
		}
            ddv[,f]=ddv[,f-1]+muh+(cc %*% rz)
        }
        dda[,,e]=ddv
        k1v=ddv[1,1:lx]
        k2v=ddv[2,1:lx]
        qv=exp(k1v+k2v*(xv-xbar))
        qv=qv/(1+qv)  # vector of mortality rates for this sample path
		 	    # and for the cohort initially aged x0
        pv=(1-qv)	    # convert into survival probabilities
        pa[,e]=pv	    # store in the summary matrix
        tpa[,e]=exp(cumsum(log(pv))) # vector for the cohort survivor index

        # now do the qtx's by age xx[i]
	  for(i in 1:lxx)
        {
	      qv0=exp(k1v+k2v*(xx[i]-xbar))
        	qv0=qv0/(1+qv0)
	      qaa[i,,e]=qv0
	  }
    }

        list(y=yy[n]+(1:tmax)-1,xx=xx,xv=xv,muh=muh,vh=vh,dda=dda,pa=pa,tpa=tpa,qaa=qaa)
}



fan=function(yv,mat,pl=0,color){
# This function plots a fan chart
# The outer limits are the 5% and 95% quantiles for a given year or age
# The bands in between are 5% quantiles
# The darkest band in the middle encompasses the 45% to 55% quantile range
# Default pl=0 means that the y axis starts at 0 and that the quantity
# of interest is positive
# Choose e.g. pl=1 to set the y axis up in a different way
		 qv=c(0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45)
		 ny=length(yv)
		 yy=c(yv,yv[ny:1])
		 #if(pl == 0){ setaxes(yv[1],yv[ny],0,max(mat)*1.1) }
		 #else{ setaxes(yv[1],yv[ny],min(mat),max(mat)) }
		 for(i in 1:length(qv)){
		 		 v1=yv*0
		 		 v2=v1
		 		 for(j in 1:ny){
		 		 		 v1[j]=quantile(mat[j,],qv[i])
		 		 		 v2[j]=quantile(mat[j,],1-qv[i])
		 		 }
		 		 vv=c(v1,v2[ny:1])
				 #plot(c(1961,2054),c(min(k_est),max(k_est)),type="n",main="Kappa_t: estimates + projections (percentiles)",ylab="",xlab="Time")
				 # red fan
				 if(color=="red"){
		 		 polygon(yy,vv,border=NA,col=rgb(1,(0.5-qv[i])*2,(0.5-qv[i])*2))
				 }
				 # blue fan
			       if(color=="blue"){
				 polygon(yy,vv,border=NA,col=rgb((0.5-qv[i])*2,(0.5-qv[i])*2,1))
				 }
				 # green fan
				 if(color=="green"){
				   polygon(yy,vv,border=NA,col=rgb((0.5-qv[i])*2,1,(0.5-qv[i])*2))
				 }
		 }
}


# example simulations
# res105A is the result of fitting model M5 using fit705 with the full
# 44 year dataset
# we use the last 20 years though to estimate the random walk model

# res=sim2005(res105A$x,res105A$y,res105A$kappa1,res105A$kappa2,nsim=1000,nyears=20,tmax=40,x0=60)
# fan(res$xv,res$tpa)		 		 # fan chart for cohort survival index
# fan(res$y,res$qaa[25,,])		 # fan chart for mortality rates at age xx[25]


par1=function(){
		 par(mfrow = c(1, 1))
		 par(mar = c(6, 4, 2, 1), lwd = 1, xaxs = "i", yaxs = "i", tck = -0.02, err = -1.)
		 0
}

setaxes=function(x0, x1, y0, y1, l = ""){
		 plot(c(x0, x1), c(y0, y1), log = "y", xlab = "", ylab = "", type = "n")
}


cumplot=function(x,a=1,co=1){
		 x=x[order(x)]
		 l=length(x)
		 nv=1:l
		 nv2=nv*2
		 nv1=nv2-1
		 xv=(1:(2*l))*0
		 yv=xv
		 xv[nv1]=x
		 xv[nv2]=x
		 yv[nv1]=(0:(l-1))/l
		 yv[nv2]=(1:l)/l
		 dx=max(x)-min(x)
		 x0=min(x)-0.02*dx
		 x1=max(x)+0.02*dx
		 if(a==1){ setaxes(x0,x1,0,1) }
		 lines(xv,yv,col=co)
}



